# 第 6 章：指针

## 6.17 问题

1. **如果一个值的类型无法简单地通过观察它的位模式来判断，那么机器如何知道该怎样对这个值进行操纵的？**

    > **机器无法做出判断。编译器根据值的声明类型创建适当的指令，机器只是盲目地执行这些指令而已**

2. **C 为什么没有一种方法来声明字面值指针常量呢？**

    > 除了 NULL 指针，不可以使用其他指针常量，因为我们不清楚该常量所指向的内存是否合法，且不能确定其中内容是否可以修改。

3. **假定一个整数的值是 244，什么机器不会把这个值解释为一个内存地址呢？**

    > 因为该数的数据类型为整数，而不是一个指针类型。数据在存取时，编译器会根据其类型对其中的数据进行解释。

4. **在有些机器上，编译器在内存位置存储 0 这个值。对 NULL 指针进行解引用操作将访问这个位置。这种方法会产生什么后果？**

    > 这样可以 通过 NULL 得到该地址，并对其中内容进行篡改。

5. **表达式（a）和（b）的求值过程有没有区别？如果有的话，区别在哪里？假定变量 offset 的值为 3。**

    ```c
    int i[10];
    int *p = &i[0];
    int offset;
    p += offset;	(a)
    p += 3;			(b)
    ```

    > 过程 (a) 比过程 （b) 多了使用变量名到 offset 中取值的过程。

6. **下面的代码段有没有问题？如果有的话，问题在哪里？**

    ```c
    int array[ARRAY_SIZE];
    int *pi;
    for (pi=&array[0]; pi < &array[ARRAY_SIZE];)
        *++pi=0;
    ```

    > 存在问题，++pi，先把指针指向了元素 1,0号位置没有被赋值，同时最后一次运行访问越界。

7. 



